RUBY ON RAILS 
# .erb -- Embedded Ruby

STARTING AN APP

IN COMMAND PROMPT: (ENTER IN THIS ORDER)

GENERATE NEW RAILS APP
rails new SiteName (1)
# creates a new Rails app named SiteName

bundle install (2)
# Note: always cd into the SiteName prior to installing the gems.
# installs all the software packages, called gems, that are required by the new app.

rails server (3)
# starts the Rails development server so we could preview the app in browser by visiting http://localhost:8000,
# the development server called "WEBrick"

GENERATE CONTROLLER
rails generate controller Pages (4)
# generates a controller that is required for the request/response cycle
# "controller actions" - these are methods in Rails controllers.
# controller name "Pages" for static websites.
# controller is saved as js/app/controllers/pages_controller.rb in file structure
i.e. "Pages" <> "pages_controller.rb"

# actions must be added for EACH page that will exist
  def home; end;
  def about; end;

CREATE A ROUTE 
# save routes in "config/routes.rb"
get "welcome" => "pages#home" (5)
get "pagenameurl" => "controller#action_name"
# creates a route for when to send the requested http://localhost:8000/welcome to the "pages" controller: "home" action.
# maps a URL to the controller action.
e.g. "welcome" === "http://localhost:8000/welcome"
     "pages#home" === "js/app/controllers/pages_controller: def home; end."

OR

root 'pages#home'
# route tells Rails to map requests for the url "/" to the Pages controller's "home" action.

create a view (6)

APPLICATION PREVIEW:
rails s -p 8080 -b 0.0.0.0 # view application in terminal
http://localhost:8080 in browser.

APPLICATION LAYOUT
app/views/layouts/application.html.erb
# base view that contains common elements for your site:
# this includes: CSS file links, the header and the footer:
	<%= yield %>
# the yield within the template yields to the child templates, such as home.html.erb and about.html.erb

CREATING A MODEL >>>

GENERATING A MODEL (1)
rails generate model Messsage
# required for data input rubies application
# https://www.codecademy.com/articles/request-response-cycle-dynamic # view for Request/Response Data Cycle
# this does two things:
# 1. Generates a model file in app/models/message.rb. The model represents a table in the database.
# 2. Generates a migration file in db/migrate/. Migrations are a way to update the database. 

EDIT MIGRATIONS FOR MODELS (2)
# "change" METHOD tells Rails what changes to make to the database.
# "create_table" COMMAND WITHIN METHOD creates a new table in database for storing mesages.
# "t.text :content" COMMAND WITHIN METHOD. Will create text column called content in messages table.
# "t.timestamps" COMMAND WITHIN METHOD. Create two further columns in messages table. a "created_at" and "updated_at"
# "t.references :tag" COMMAND WITHIN METHOD. Creates a "foreign key" pointing to "tag"s given table.
# (these are automatically updated)

UPDATED DATABASE (3)
rake db:migrate
# updates database with new messages data model.

SEED SAMPLE DATA IN DATABASE (4)
rake db:seed
# seeds database with sample data from db/seeds.rb
# use this to seed the database with default values.

STANDARD CONTROLLER ACTIONS FOR DATA MANIPULATION (5)

resources :controller_name
# in routes.rb file.

# 7 USEFUL DATA ACTIONS: index, show, new, create, edit, update, and destroy
# suite of controller actions and associated routes, to pre-poulate
# https://www.codecademy.com/articles/standard-controller-actions
# https://www.codecademy.com/courses/learn-rails/lessons/one-model/exercises/one-model-view?action=lesson_resume

rake routes 
# used to view created routes.

# get '/tags/:id' => 'tags#show', as: :tag
# use of "as:" to name this given route "tag"

e.g.
routes.rb file:
get "messages" => "messages/index"

USEFUL CONTROLLER ACTIONS

def index
  @messages = Message.all
end
def new
    @message = Message.new
  end

private 
  def message_params 
    params.require(:message).permit(:content) 
  end

# "http://localhost:8000/messages" : controller maps URS request to message controller's index action.
# "index" action created to save all messages in local variable. This to be passed on to viewer.
# "new" action created in messages controller. 

INTERROGATING DATABASES

1. Start new consold
2. cd rails-app
3. rails console
4. Model.all

VIEW ALL NEW URLs CREATED BY {e.g. resources :Signup)
 routes

form_for

Use this in erb html to make ease of formfor.


HTTP request methods:

GET - Requests data from a specified resource
POST - Submits data to be processed to a specified resource

ADD COLUMNS TO TABLES

1. rails generate model Name (generates table called name)
2. open migrate file in /db
3. add t.type :name (e.g. t.string :username)
4. Run migration to update database with Name model.

## START THE RAILS CONSOLE ##

rails console

Use this to interrogate the application: 

User.all
## retrieves all signed-up users.

> User.create(first_name: "Edna", last_name: "Mode", email: 'edna@example.com', password: 'incredibles')
## manually adds a user through the console, rather than a PUT request from the interface.

> myuser = User.find_by(first_name: "David")
## finds user in database

> myuser.name 
## retrieves object property "name" or "email" etc

> myuser.save
## saves user details

> myuser.authenticate("password") 
## compares entered "password" with 'bcrypt' encrypted password. If incorrect, returns false. 
## if correct, returns full myuser object details.

http://guides.rubyonrails.org/active_record_basics.html#read 
## for library of 'active record basics' to put into the console.



##BASIC RAILS SETUP##

1. Setup
2. Add a model
3. Add a controller (same name) and routes
4. Add controller actions and views
5. Check the database

ASSOCIATIONS

1. Create two models "Tag" and "Destinations" 
2. Add methods to define associations within each:

One-to-many relationship defined with "has many / belongs_to" tags
// 3. "has_many :destinations" (Tag model) denotes that a single Tag can have multiple destinations.
// 4. "belongs_to :tag" (Destinations model) denotes that each Destination belongs to a single tag.
// e.g. library has many Books (one to many). a book belongs to a library (many to one)
//      album has many photos (one to many). a photo belongs to an album (many to one)
//      store has many products (one to many). a product belongs to a store (many to one) 

3. Customise models
// include new "t.type :name" columns to given :tag and :destinations as required.
// "t.references :tag" includes a "foreign key" pointing to given table. (THIS IS REQUIRED WITH BELONGS_TO)

USE FOR INPUT PARAMETERS FROM CLICKED ON OBJECT

  def edit
    @destination = Destination.find(params[:id])
    @keyplaces = @destination.keyplaces
  end

// takes :id from clicked on object

## MANY TO MANY ASSOCIATIONS ##

## MODEL SETUPS - set up this way to map a many to many relationship with these 3x models

class Actor
	has_many :parts
	has_many :movies, through: :parts
end

class Movie
	has_many :parts
	has_many :movies, through: :parts
end

class Part
	belongs_to :movie
	belongs_to :actor
end

DEPLOY RAILS APP TO INTERNET

https://www.codecademy.com/articles/deploy-rails-to-heroku

MAPPING DOMAINS FOR LAUNCH

https://www.codecademy.com/articles/map-a-custom-domain 

## AUTHENTICATION ##

Creating authentication 
1. Create model "User"
2. Add method "has_secure_password" to "User" model: Adds functionality to save passwords securely.
3. Add "bcrypt" gem to the Gemfile. This is an algorithm used to save passwords securely. This can probably be uncommented.
4. Generate "Users" Controller.
5. Create Sign-up form using Embedded Ruby / map route.
6. Take in User entered parameters in User Controller:

private
  def user_params
    params.require(:user).permit(:first_name, :last_name, :email, :password)
  end

7. Add the create action

def create 
  @user = User.new(user_params) 
  if @user.save 
    session[:user_id] = @user.id 
    redirect_to '/' 
  else 
    redirect_to '/signup' 
  end 
end

## NOTE: "session[:user_id] = @user.id" creates a new session.
## sessions are stored in key-value pairs where the value @user.id is mapped to the key :user_id

## LOGIN AUTHENTICATION FORM (WITH CONTROLLER SESSION)##

1. Generate Sessions Controller
2. Create route that maps "login" URL to session's new controller
3. Create login form in relevant view:

      <%= form_for(:session, url: login_path) do |f| %> 
  	<%= f.email_field :email, :placeholder => "Email" %> 
  	<%= f.password_field :password, :placeholder => "Password" %> 
  	<%= f.submit "Log in", class: "btn-submit" %>
      <% end %>

## NOTE: In the login form, we use form_for(:session, url: login_path) do |f|. 
## This refers to the name of the resource and corresponding URL

4. Create post route to create method:

post 'login' => 'sessions#create'

5. Define Create method:

def create
  @user = User.find_by_email(params[:session][:email])
  if @user && @user.authenticate(params[:session][:password])
    session[:user_id] = @user.id
    redirect_to '/'
  else
    redirect_to 'login'
  end 
end


## LOGOUT PROCEDURE ##

1. Add route: delete "logout" => "sessions#destroy"
2. Add destroy action to sessions controller:

def destroy 
  session[:user_id] = nil 
  redirect_to '/' 
end

